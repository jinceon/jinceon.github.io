# 本末倒置之规范
## 故事
在一个项目里看到一个奇怪的“规范”。

如果需要用到缓存，必须将这个Service再包一层CacheService。

举一个不符合该“规范”的例子
```java
public class RuleService{
    
    @Cacheable(cacheNames="rules", key="#expr")
    public Rule calcRule(String expr){
        Rule rule = complexCalculate(expr);
        return rule;
    }
}
```
按该“规范”，你必须要改成
```java
public class RuleService{

    public Rule calcRule(String expr){
        Rule rule = complexCalculate(expr);
        return rule;
    }
}

// 增加一个 cacheService
public class RuleCacheService{

    private RuleService ruleService;
    
    @Cacheable(cacheNames="rules", key="#expr")
    public Rule calcRule(String expr){
        return ruleService.calcRule(expr);
    }
}
```
我真的是百思不得其解。问，为什么要这样做？

答，统一、规范、方便管理。

## 观点
我真的是麻了。

这是一个典型的本末倒置的错误。

**规范从始至终就不是目标，规范只是手段而已。**

我们的目标从来就是建设一个可维护、好维护、易维护的系统。

为了实现这个目标，解决一些特定的问题，我们才去针对性制定了一些规范，
期望通过这些规范去避免那些可预料的问题，或者给我们带来一些额外的好处。

你要统一，你要方便管理？

就上面这个cache的例子，你要管理什么？

以前缓存都是硬编码在业务代码逻辑内，如
```java
public class RuleService{
    
    public Rule calcRule(String expr){
    
        //先试图从cache拿
        if(cache.get(expr) != null){
            return cache.get(expr);
        }
        
        Rule rule = complexCalculate(expr);
        
        // 放到cache
        cache.set(expr, rule);
        
        return rule;
    }
}
```
大牛们将cache抽离成@Cacheable，让我们可以专注于业务逻辑，不必再关心cache这些技术性问题。

现在他一个“规范”下来，硬是让大家回到了解放前。